1. Скачайте библиотеку *boost* с помощью утилиты **wget**. Адрес для скачивания `https://sourceforge.net/projects/boost/files/boost/1.69.0/boost_1_69_0.tar.gz`.
```sh
$ wget https://sourceforge.net/projects/boost/files/boost/1.69.0/boost_1_69_0.tar.gz
```
[[![2023-02-28_19-24-10](https://user-images.githubusercontent.com/112760887/221917101-5cd37433-6cb9-4bf7-b35c-9a966448ddaa.png)
]]
2. Разархивируйте скаченный файл в директорию `~/boost_1_69_0`
```sh
$ tar -xf boost_1_69_0.tar.gz -C ~
$ cd ~/boost_1_69_0
```
3. Подсчитайте количество файлов в директории `~/boost_1_69_0` **не включая** вложенные директории.

> **find** — выводит найденные в директории файлы как последовательность строк — полных путей к ним
> 
> Флаг `-maxdepth` указывает максимальную глубину поиска
> 
> Символ `!` — логическое отрицание
> 
> Флаг `-type` задаёт условие, что файл должен иметь данный тип. `d` — директория, `f` — обычный файл, остальное знать не обязательно.
> 
> **Символ** `|` говорит, что результат первой команды надо подать на вход второй
> 
> **wc** — выводит количество строк, слов и байт в текстовом файле
> 
> Получаем, что команда получает список всех файлов, находящиеся непосредственно в данной директории,и считает количество строк, слов и байт в нём. Количество строк и есть количество файлов.

```sh
$ find -maxdepth 1 ! -type d  | wc
```
4. Подсчитайте количество файлов в директории `~/boost_1_69_0` **включая** вложенные директории.

> Без флага `-maxdepth` команда `find` пробегает по вообще всем файлам, включая те, что находятся во вложенных директориях.

```sh
$ find ! -type d | wc
```
5. Подсчитайте количество заголовочных файлов, файлов с расширением `.cpp`, сколько остальных файлов (не заголовочных и не `.cpp`).

> Флаг `-name` говорит, что имя файла должно соответсвтовать указанному паттерну. 

```sh
$ find ! -type d -name "*.h" | wc
$ find ! -type d -name "*.cpp" | wc
$ find ! -type d ! -name "*.cpp" ! -name "*.h" | wc
```
6. Найдите полный пусть до файла `any.hpp` внутри библиотеки *boost*.

> Напомню, команда `find` выводит полные пути до файлов

```sh
$ find -name "any.hpp"
./boost/fusion/include/any.hpp
./boost/fusion/algorithm/query/detail/any.hpp
./boost/fusion/algorithm/query/any.hpp
./boost/proto/detail/any.hpp
./boost/hana/fwd/any.hpp
./boost/hana/any.hpp
./boost/xpressive/detail/utility/any.hpp
./boost/any.hpp
./boost/type_erasure/any.hpp
./boost/spirit/home/support/algorithm/any.hpp
```
7. Выведите в консоль все файлы, где упоминается последовательность `boost::asio`.

> **grep** — пробегается по содержанию каждого файла в директории и выводит строки, содержащие данный на вход фрагмент
>
> Флаг `-l` — вместо строки выводит имя файла
>
> Флаг `-r` — пробегается по всем файлам, включая вложенные директории

```sh
$ grep -lr "boost::asio"
```
8. Скомпилирутйе *boost*. Можно воспользоваться [инструкцией](https://www.boost.org/doc/libs/1_61_0/more/getting_started/unix-variants.html#or-build-custom-binaries) или [ссылкой](https://codeyarns.com/2017/01/24/how-to-build-boost-on-linux/).


```sh
$ ./bootstrap.sh
$ sudo ./b2 install
```
9. Перенесите все скомпилированные на предыдущем шаге статические библиотеки в директорию `~/boost-libs`.

> Обратите внимание, что первым аргументом команде `cp` подаётся результат команды `find -name "*.a"`. Команда выполнится для всех найденных файлов с расширением `.a`.
>
> **Важно:** на некоторых машинах для копирования потребуется приставка `sudo`.

```sh
$ mkdir ~/boost-libs
$ cp `find -name "*.a"` ~/boost-libs
```
10. Подсчитайте сколько занимает дискового пространства каждый файл в этой директории.

> Флаг `-exec {} +` — для каждого найденного файла выполняется команда
> 
> **du** — выводит вес каждого файла
> 
> Флаг `-h` — преобразует вес в удобный для чтения формат
> 
> Символы `{} +` — часть синтаксиса флага `-exec`. Сам не вникал, как и зачем оно работает.

```sh
$ cd ~/boost-libs
$ find ! -type d -exec du -h {} +
```
11. Найдите *топ10* самых "тяжёлых".

> **sort** — сортирует строки
> 
> Флаг `-r` — сортировка по убыванию
> 
> Флаг `-n` — сортировка по числам
> 
> **head** — оставляет только первые *n* строк
> 
> Флаг `-n` — указывает количество строк, которые надо оставить.

```sh
$ find ! -type d -exec du {} + | sort -rn | head -n 10
```
